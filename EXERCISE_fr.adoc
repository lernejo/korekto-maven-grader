= Maven et int√©gration continue
:tip-caption: üí°
:note-caption: ‚ÑπÔ∏è
:warning-caption: ‚ö†Ô∏è
:icons: font
:hardbreaks-option:

Pr√©fix√© par ‚úî, des "checkpoints" pour vous aider √† v√©rifier que vous avez tout bon.

== Objectif

Manipuler Maven et savoir √©crire un test unitaire.

== Pr√©requis

* Git
* Java 21
* Maven 3.9.x
* (Optionnel, mais fortement recommand√©) IntelliJ edition _community_ 2024

'''

== Partie 1 - premier commit

* Cr√©er un nouveau d√©p√¥t Git **priv√©** sur la plateforme GitHub avec le nom *maven_training* [.underline]#initialis√©# avec un fichier README.md (case √† cocher dans le formulaire de cr√©ation de d√©p√¥t)
* Une fois le d√©p√¥t cr√©√©, installer l'app https://github.com/apps/korekto[Korekto], ou mettre √† jour sa configuration afin qu'elle ait acc√®s √† ce nouveau d√©p√¥t
* Cloner ce nouveau d√©p√¥t en utilisant l'*url SSH*
* La branche par d√©faut est la branche *main* c'est sur celle-ci que nous allons travailler
* Ajouter un fichier *.editorconfig* √† la racine du d√©p√¥t avec le contenu suivant

[source,EditorConfig]
----
root = true

[*]
end_of_line = lf
insert_final_newline = true

charset = utf-8

indent_style = space
indent_size = 4
----

.A quoi √ßa sert ?
[%collapsible]
====

[TIP]
=====
Ce fichier (**.editorconfig**) est reconnu par un grand nombre d'IDE (IntelliJ, Eclipse, VS code, etc.) et va permettre de ne pas avoir √† se soucier

* du type d'indentation (ici 4 espaces)
* de l'encodage (ici UTF-8)
* du type de fin de ligne (ici `LF`)
* de la ligne vide √† la fin de chaque fichier (bonne pratique Git)

Pour plus d'information : https://editorconfig.org/
=====
====

* ajouter un fichier *.gitignore* √† la racine du d√©p√¥t avec le contenu suivant

[source,gitignore]
----
# IntelliJ
.idea/
*.iml

----

.A quoi √ßa sert ?
[%collapsible]
====

[TIP]
=====

Ce fichier (**.gitignore**) est reconnu par Git afin d'ignorer les changements des fichiers correspondants.
Dans notre cas, les fichiers que g√©n√®re IntelliJ ne sont pas n√©cessaires car :

* un autre IDE (Eclipse, VS code, etc.) n'en aura pas besoin
* le build automatique (CI) n'en a pas besoin
* le projet peut donc √™tre construit sans
=====
====

* faire un commit contenant ces deux fichiers avec le message **Setup project layout**
* pusher ce nouveau commit (sur votre remote par d√©faut, en l'occurrence GitHub)

== Partie 2 - Maven

Maven est outil qui g√®re le cycle de vie d'un projet Java (ou d'autres languages sur la JVM par extension).
Le point d'entr√©e dans un projet pour Maven est le fichier descripteur du projet appel√© **pom.xml**.
Pour un projet Java, Maven s'attend √† trouver le code de production dans le r√©pertoire **src/main/java** et le code de test dans **src/test/java**.
Tous les fichiers g√©n√©r√©s par Maven seront plac√© dans le r√©pertoire **target**.

* cr√©er un fichier **pom.xml** √† la racine du d√©p√¥t avec le contenu suivant

[source,xml]
----
<?xml version="1.0"?>
<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <modelVersion>4.0.0</modelVersion>

    <groupId>fr.lernejo</groupId>
    <artifactId>maven_training</artifactId>
    <version>1.0.0-SNAPSHOT</version>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
    </properties>
</project>

----

* cr√©er un fichier **Sample.java** dans le r√©pertoire **src/main/java/fr/lernejo** avec le contenu suivant

[source,java]
----
package fr.lernejo;

import java.util.function.BiFunction;

public class Sample {

    public int op(Operation op, int a, int b) {
        return op.func.apply(a, b);
    }

    public int fact(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("N should be positive");
        }
        return n == 0 ? 1 : n * fact(n - 1);
    }

    enum Operation {
        ADD((a, b) -> a + b),
        MULT((a, b) -> a * b),
        ;

        final BiFunction<Integer, Integer, Integer> func;

        Operation(BiFunction<Integer, Integer, Integer> func) {
            this.func = func;
        }
    }
}

----

* lancer la commande `mvn compile`
* ‚úî la classe compil√©e **Sample.class** correspondante a √©t√© g√©n√©r√©e dans **target/classes/fr/lernejo**
* dans le fichier **.gitignore** ajouter le contenu suivant afin d'ignorer les fichiers g√©n√©r√©s par Maven

[source,gitignore]
----
# Maven
target/
----
* ‚úî avec la commande `git status` trois fichiers apparaissent :
** .gitignore
** pom.xml
** src/main/java/fr/lernejo/Sample.java
* faire un commit contenant ces trois modifications avec le message "Setup Maven"

== Partie 3 - Maven wrapper
Afin de pouvoir construire le projet sans avoir besoin d'installer Maven, nous allons utiliser **Maven Wrapper**.
Cet outil permet d'ajouter des scripts (unix et windows) autosuffisant pour le lancement de Maven (comprendre, qui
t√©l√©charge les binaires si n√©cessaires).

* Executer la commande `mvn -N io.takari:maven:0.7.7:wrapper`
* Ajouter √† l'index Git les fichiers r√©sultants en s'assurant que le script **mvnw** l'est bien en [.underline]#√©criture#
** avec la commande `git update-index --add --chmod=+x mvnw`
** ne pas oublier d'indexer les fichiers g√©n√©r√©s dans le r√©pertoire **.mvn** visibles avec la commande `ls -al`
* Commiter les fichiers r√©sultants avec le message "Setup Maven Wrapper"

## Partie 4 - CI

L'int√©gration continue (CI pour Continuous Integration) est un service attach√© au projet permet de lancer les
diff√©rentes √©tapes de sa construction √† chaque fois qu'un changement est apport√©.

Dans cet exercice, nous allons utiliser le service propos√© par GitHub.

* cr√©er un fichier **.github/workflows/build.yml** avec le contenu

[source,yml]
----
name: Build

on: push

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: maven

      - run: |
         java -version
         echo $JAVA_HOME

      - run: ./mvnw install

      - uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
----

.A quoi √ßa sert ?
[%collapsible]
====

[TIP]
=====
Ce fichier (**build.yml**) est reconnu par GitHub et permet de d√©clencher √† chaque *push* une construction du projet
constitu√©e des √©tapes suivantes :

* checkout du code
* installation de Java 17
* mise en cache (et r√©cup√©ration) des d√©pendances Maven du projet
* affichage de la version de java install√©e (pour info)
* lancement de la commande `mvnw install`
* upload du r√©sultat de la couverture des tests sur Codecov
=====
====

* Commiter ce fichier avec le message "Setup GitHub CI"
* ‚úî Dans l'interface web GitHub de votre projet, dans l'onglet *Actions*, un nouveau workflow d√©marre et celui-ci doit se finir en succ√®s

== Partie 5 - Code coverage

* Dans le fichier *pom.xml* ajouter
* les quatre properties suivantes
[source,xml]
----
<properties> <!-- balise existante -->
  ...
  <junit.version>5.9.1</junit.version>
  <assertj.version>3.23.1</assertj.version>

  <maven-surefire-plugin.version>2.22.2</maven-surefire-plugin.version>
  <jacoco-maven-plugin.version>0.8.8</jacoco-maven-plugin.version>
</properties>
----

* les d√©pendances suivantes

[source,xml]
----
<dependencies>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>${junit.version}</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.assertj</groupId>
        <artifactId>assertj-core</artifactId>
        <version>${assertj.version}</version>
        <scope>test</scope>
    </dependency>
</dependencies>
----

* et les plugins suivants

[source,xml]
----
<build>
    <pluginManagement>
        <plugins>
            <plugin>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>${maven-surefire-plugin.version}</version>
            </plugin>
            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <version>${jacoco-maven-plugin.version}</version>
            </plugin>
        </plugins>
    </pluginManagement>
    <plugins>
        <plugin>
            <groupId>org.jacoco</groupId>
            <artifactId>jacoco-maven-plugin</artifactId>
            <executions>
                <execution>
                    <goals>
                        <goal>prepare-agent</goal>
                    </goals>
                </execution>
                <execution>
                    <id>report</id>
                    <phase>test</phase>
                    <goals>
                        <goal>report</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
----

.A quoi √ßa sert ?
[%collapsible]
====

[TIP]
=====
Nous ajoutons au projet les d√©pendances

* **junit-jupiter**, un framework servant √† √©crire et lancer des tests
* **assertj**, une biblioth√®que permettant d'√©crire des assertions expressives

Par ailleurs, par d√©faut Maven utilise une version du plugin **surefire** qui ne reconna√Æt pas **junit-jupiter**, c'est pour √ßa que nous devons le forcer √† une version plus r√©cente.
Enfin, nous utilisons le plugin **jacoco** afin d'analyser la couverture de code et produire le rapport correspondant.
=====
====

* Ouvrir IntelliJ et importer le projet en choisissant `File` -> `New` -> `Project from Existing Sources...` et en s√©lectionnant le fichier *pom.xml*
* Cr√©er le r√©pertoire src/test/java (clic droit sur `maven_training` -> `New` -> `Directory`) qui va accueillir les classes de test
* Ouvrir la classe Java *Sample* et cr√©er la classe de test correspondante en utilisant le raccourci (Ctrl + Shift + T)
ou par le menu `Navigate` -> `Test`
* Ajouter les tests n√©cessaires √† une couverture du code √† 100 %

.Qu'est-ce qu'un test ?
[%collapsible]
====
[TIP]
=====
Un test est constitu√© de trois parties

* les mises en condition initiale (0..n)
* un √©l√©ment d√©clencheur (1)
* des v√©rifications sur l'√©tat r√©sultant (1..n)

Exemples :
[source,java]
----
   @Test
   void dividing_by_zero_should_produce_an_exception() {
       int dividend = 10;
       int divisor = 0;
       Assertions.assertThatExceptionOfType(DivisionByZeroException.class)
             .isThrownBy(() -> Sample.divide(dividend, divisor));
   }

   @Test
   void dividing_10_by_2_should_produce_5() {
       int dividend = 10; // <1>
       int divisor = 2;
       int quotient = Sample.divide(dividend, divisor); // <2>
       Assertions.assertThat(quotient).as("quotient of 10 / 2")
             .isEqualTo(5); // <3>
   }
----
<1> Mise en condition initiale : on initialise deux variables
<2> √âl√©ment d√©clencheur : la m√©thode `Sample#divide` est appel√©e
<3> V√©rification : le r√©sultat doit √™tre 5

=====
====

* Commiter ces changements avec le message "Add test to match 100% coverage"

== Partie 6 - Live badges

Pour suivre l'√©tat d'un projet, il peut √™tre plus simple d'afficher des indicateurs visuels sur la page principale.
C'est l√† l'int√©r√™t des badges. Ces petites images refl√®tent l'√©tat actuel du projet par rapport aux derni√®res executions de la CI.

* Dans le fichier README.md ajouter les badges suivants
** build CI (cf https://docs.github.com/en/actions/managing-workflow-runs/adding-a-workflow-status-badge)
** couverture par les tests (cf https://codecov.io/gh/<your-name>/<your-project>/settings/badge)
* Commiter ce changement avec le message "Add live badges"
* ‚úî Dans l'interface web GitHub de votre projet, le fichier README affich√© par d√©faut doit contenir les deux badges indiquant que le build est en succ√®s et que la couverture par les tests est de 100 %

[TIP]
=====
Si le badge de couverture apparait en gris, il est possible que Codecov n'est pas re√ßu l'information de couverture.

Pour _troubleshooter_ ce probl√®me, v√©rifier dans les executions de votre workflow de CI (onglet `Action` dans GitHub), les logs de l'√©tape correspondante √† l'action codecov.
=====
